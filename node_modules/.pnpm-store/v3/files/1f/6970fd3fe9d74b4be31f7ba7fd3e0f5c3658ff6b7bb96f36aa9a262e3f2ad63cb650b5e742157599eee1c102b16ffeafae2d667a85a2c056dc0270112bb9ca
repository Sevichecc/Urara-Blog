{"version":3,"file":"twoslash.cjs.production.min.js","sources":["../src/utils.ts","../src/index.ts","../src/validation.ts"],"sourcesContent":["import { TwoslashError } from \"./\"\n\nexport function escapeHtml(text: string) {\n  return text.replace(/</g, \"&lt;\")\n}\n\nexport function strrep(text: string, count: number) {\n  let s = \"\"\n  for (let i = 0; i < count; i++) {\n    s += text\n  }\n  return s\n}\n\nexport function textToAnchorName(text: string) {\n  return text\n    .toLowerCase()\n    .replace(/ /g, \"-\")\n    .replace(/`|#|\\//g, \"\")\n}\n\nexport function fileNameToUrlName(s: string) {\n  return s.replace(/ /g, \"-\").replace(/#/g, \"sharp\").toLowerCase()\n}\n\nexport function parsePrimitive(value: string, type: string): any {\n  switch (type) {\n    case \"number\":\n      return +value\n    case \"string\":\n      return value\n    case \"boolean\":\n      return value.toLowerCase() === \"true\" || value.length === 0\n  }\n\n  throw new TwoslashError(\n    `Unknown primitive value in compiler flag`,\n    `The only recognized primitives are number, string and boolean. Got ${type} with ${value}.`,\n    `This is likely a typo.`\n  )\n}\n\nexport function cleanMarkdownEscaped(code: string) {\n  code = code.replace(/¨D/g, \"$\")\n  code = code.replace(/¨T/g, \"~\")\n  return code\n}\n\nexport function typesToExtension(types: string) {\n  const map: Record<string, string> = {\n    js: \"js\",\n    javascript: \"js\",\n    ts: \"ts\",\n    typescript: \"ts\",\n    tsx: \"tsx\",\n    jsx: \"jsx\",\n    json: \"json\",\n    jsn: \"json\",\n  }\n\n  if (map[types]) return map[types]\n\n  throw new TwoslashError(\n    `Unknown TypeScript extension given to Twoslash`,\n    `Received ${types} but Twoslash only accepts: ${Object.keys(map)} `,\n    ``\n  )\n}\n\nexport function getIdentifierTextSpans(ts: typeof import(\"typescript\"), sourceFile: import(\"typescript\").SourceFile) {\n  const textSpans: { span: import(\"typescript\").TextSpan; text: string }[] = []\n  checkChildren(sourceFile)\n  return textSpans\n\n  function checkChildren(node: import(\"typescript\").Node) {\n    ts.forEachChild(node, child => {\n      if (ts.isIdentifier(child)) {\n        const start = child.getStart(sourceFile, false)\n        textSpans.push({ span: ts.createTextSpan(start, child.end - start), text: child.getText(sourceFile) })\n      }\n      checkChildren(child)\n    })\n  }\n}\n\nexport function stringAroundIndex(string: string, index: number) {\n  const arr = [\n    string[index - 3],\n    string[index - 2],\n    string[index - 1],\n    \">\",\n    string[index],\n    \"<\",\n    string[index + 1],\n    string[index + 2],\n    string[index + 3],\n  ]\n  return arr.filter(Boolean).join(\"\")\n}\n\n/** Came from https://ourcodeworld.com/articles/read/223/how-to-retrieve-the-closest-word-in-a-string-with-a-given-index-in-javascript */\nexport function getClosestWord(str: string, pos: number) {\n  // Make copies\n  str = String(str)\n  pos = Number(pos) >>> 0\n\n  // Search for the word's beginning and end.\n  var left = str.slice(0, pos + 1).search(/\\S+$/),\n    right = str.slice(pos).search(/\\s/)\n\n  // The last word in the string is a special case.\n  if (right < 0) {\n    return {\n      word: str.slice(left),\n      startPos: left,\n    }\n  }\n  // Return the word, using the located bounds to extract it from the string.\n  return {\n    word: str.slice(left, right + pos),\n    startPos: left,\n  }\n}\n","let hasLocalStorage = false\ntry {\n  hasLocalStorage = typeof localStorage !== `undefined`\n} catch (error) {}\nconst hasProcess = typeof process !== `undefined`\nconst shouldDebug = (hasLocalStorage && localStorage.getItem(\"DEBUG\")) || (hasProcess && process.env.DEBUG)\n\ntype LZ = typeof import(\"lz-string\")\ntype TS = typeof import(\"typescript\")\ntype CompilerOptions = import(\"typescript\").CompilerOptions\ntype CustomTransformers = import(\"typescript\").CustomTransformers\n\nimport { parsePrimitive, cleanMarkdownEscaped, typesToExtension, getIdentifierTextSpans, getClosestWord } from \"./utils\"\nimport { validateInput, validateCodeForErrors } from \"./validation\"\n\nimport { createSystem, createVirtualTypeScriptEnvironment, createFSBackedSystem } from \"@typescript/vfs\"\n\nconst log = shouldDebug ? console.log : (_message?: any, ..._optionalParams: any[]) => \"\"\n\n// Hacking in some internal stuff\ndeclare module \"typescript\" {\n  type Option = {\n    name: string\n    type: \"list\" | \"boolean\" | \"number\" | \"string\" | import(\"typescript\").Map<any>\n    element?: Option\n  }\n\n  const optionDeclarations: Array<Option>\n}\n\ntype QueryPosition = {\n  kind: \"query\" | \"completion\"\n  offset: number\n  text: string | undefined\n  docs: string | undefined\n  line: number\n}\n\ntype PartialQueryResults = {\n  kind: \"query\"\n  text: string\n  docs: string | undefined\n  line: number\n  offset: number\n  file: string\n}\n\ntype PartialCompletionResults = {\n  kind: \"completions\"\n  completions: import(\"typescript\").CompletionEntry[]\n  completionPrefix: string\n\n  line: number\n  offset: number\n  file: string\n}\n\ntype HighlightPosition = TwoSlashReturn[\"highlights\"][number]\n\nexport class TwoslashError extends Error {\n  public title: string\n  public description: string\n  public recommendation: string\n  public code: string | undefined\n\n  constructor(title: string, description: string, recommendation: string, code?: string | undefined) {\n    let message = `\n## ${title}\n\n${description}\n`\n    if (recommendation) {\n      message += `\\n${recommendation}`\n    }\n\n    if (code) {\n      message += `\\n${code}`\n    }\n\n    super(message)\n    this.title = title\n    this.description = description\n    this.recommendation = recommendation\n    this.code = code\n  }\n}\n\nfunction filterHighlightLines(codeLines: string[]): { highlights: HighlightPosition[]; queries: QueryPosition[] } {\n  const highlights: HighlightPosition[] = []\n  const queries: QueryPosition[] = []\n\n  let nextContentOffset = 0\n  let contentOffset = 0\n  let removedLines = 0\n\n  for (let i = 0; i < codeLines.length; i++) {\n    const line = codeLines[i]\n    const moveForward = () => {\n      contentOffset = nextContentOffset\n      nextContentOffset += line.length + 1\n    }\n\n    const stripLine = (logDesc: string) => {\n      log(`Removing line ${i} for ${logDesc}`)\n\n      removedLines++\n      codeLines.splice(i, 1)\n      i--\n    }\n\n    // We only need to run regexes over lines with comments\n    if (!line.includes(\"//\")) {\n      moveForward()\n    } else {\n      const highlightMatch = /^\\s*\\/\\/\\s*\\^+( .+)?$/.exec(line)\n      const queryMatch = /^\\s*\\/\\/\\s*\\^\\?\\s*$/.exec(line)\n      // https://regex101.com/r/2yDsRk/1\n      const removePrettierIgnoreMatch = /^\\s*\\/\\/ prettier-ignore$/.exec(line)\n      const completionsQuery = /^\\s*\\/\\/\\s*\\^\\|$/.exec(line)\n\n      if (queryMatch !== null) {\n        const start = line.indexOf(\"^\")\n        queries.push({ kind: \"query\", offset: start, text: undefined, docs: undefined, line: i + removedLines - 1 })\n        stripLine(\"having a query\")\n      } else if (highlightMatch !== null) {\n        const start = line.indexOf(\"^\")\n        const length = line.lastIndexOf(\"^\") - start + 1\n        const description = highlightMatch[1] ? highlightMatch[1].trim() : \"\"\n        highlights.push({\n          kind: \"highlight\",\n          offset: start + contentOffset,\n          length,\n          text: description,\n          line: i + removedLines - 1,\n          start,\n        })\n\n        stripLine(\"having a highlight\")\n      } else if (removePrettierIgnoreMatch !== null) {\n        stripLine(\"being a prettier ignore\")\n      } else if (completionsQuery !== null) {\n        const start = line.indexOf(\"^\")\n        // prettier-ignore\n        queries.push({ kind: \"completion\", offset: start, text: undefined, docs: undefined, line: i + removedLines - 1 })\n        stripLine(\"having a completion query\")\n      } else {\n        moveForward()\n      }\n    }\n  }\n  return { highlights, queries }\n}\n\nfunction getOptionValueFromMap(name: string, key: string, optMap: Map<string, string>) {\n  const result = optMap.get(key.toLowerCase())\n  log(`Get ${name} mapped option: ${key} => ${result}`)\n  if (result === undefined) {\n    const keys = Array.from(optMap.keys() as any)\n\n    throw new TwoslashError(\n      `Invalid inline compiler value`,\n      `Got ${key} for ${name} but it is not a supported value by the TS compiler.`,\n      `Allowed values: ${keys.join(\",\")}`\n    )\n  }\n  return result\n}\n\nfunction setOption(name: string, value: string, opts: CompilerOptions, ts: TS) {\n  log(`Setting ${name} to ${value}`)\n\n  for (const opt of ts.optionDeclarations) {\n    if (opt.name.toLowerCase() === name.toLowerCase()) {\n      switch (opt.type) {\n        case \"number\":\n        case \"string\":\n        case \"boolean\":\n          opts[opt.name] = parsePrimitive(value, opt.type)\n          break\n\n        case \"list\":\n          const elementType = opt.element!.type\n          const strings = value.split(\",\")\n          if (typeof elementType === \"string\") {\n            opts[opt.name] = strings.map(v => parsePrimitive(v, elementType))\n          } else {\n            opts[opt.name] = strings.map(v => getOptionValueFromMap(opt.name, v, elementType as Map<string, string>))\n          }\n          break\n\n        default:\n          // It's a map!\n          const optMap = opt.type as Map<string, string>\n          opts[opt.name] = getOptionValueFromMap(opt.name, value, optMap)\n          break\n      }\n      return\n    }\n  }\n\n  throw new TwoslashError(\n    `Invalid inline compiler flag`,\n    `There isn't a TypeScript compiler flag called '${name}'.`,\n    `This is likely a typo, you can check all the compiler flags in the TSConfig reference, or check the additional Twoslash flags in the npm page for @typescript/twoslash.`\n  )\n}\n\nconst booleanConfigRegexp = /^\\/\\/\\s?@(\\w+)$/\n\n// https://regex101.com/r/8B2Wwh/1\nconst valuedConfigRegexp = /^\\/\\/\\s?@(\\w+):\\s?(.+)$/\n\nfunction filterCompilerOptions(codeLines: string[], defaultCompilerOptions: CompilerOptions, ts: TS) {\n  const options = { ...defaultCompilerOptions }\n  for (let i = 0; i < codeLines.length; ) {\n    let match\n    if ((match = booleanConfigRegexp.exec(codeLines[i]))) {\n      options[match[1]] = true\n      setOption(match[1], \"true\", options, ts)\n    } else if ((match = valuedConfigRegexp.exec(codeLines[i]))) {\n      // Skip a filename tag, which should propagate through this stage\n      if (match[1] === \"filename\") {\n        i++\n        continue\n      }\n      setOption(match[1], match[2], options, ts)\n    } else {\n      i++\n      continue\n    }\n    codeLines.splice(i, 1)\n  }\n  return options\n}\n\nfunction filterCustomTags(codeLines: string[], customTags: string[]) {\n  const tags: TwoSlashReturn[\"tags\"] = []\n\n  for (let i = 0; i < codeLines.length; ) {\n    let match\n    if ((match = valuedConfigRegexp.exec(codeLines[i]))) {\n      if (customTags.includes(match[1])) {\n        tags.push({ name: match[1], line: i, annotation: codeLines[i].split(\"@\" + match[1] + \": \")[1] })\n        codeLines.splice(i, 1)\n      }\n    }\n    i++\n  }\n  return tags\n}\n\n/** Available inline flags which are not compiler flags */\nexport interface ExampleOptions {\n  /** Lets the sample suppress all error diagnostics */\n  noErrors: boolean\n  /** An array of TS error codes, which you write as space separated - this is so the tool can know about unexpected errors */\n  errors: number[]\n  /** Shows the JS equivalent of the TypeScript code instead */\n  showEmit: boolean\n  /**\n   * Must be used with showEmit, lets you choose the file to present instead of the source - defaults to index.js which\n   * means when you just use `showEmit` above it shows the transpiled JS.\n   */\n  showEmittedFile: string\n\n  /** Whether to disable the pre-cache of LSP calls for interesting identifiers, defaults to false */\n  noStaticSemanticInfo: boolean\n  /** Declare that the TypeScript program should edit the fsMap which is passed in, this is only useful for tool-makers, defaults to false */\n  emit: boolean\n  /** Declare that you don't need to validate that errors have corresponding annotations, defaults to false */\n  noErrorValidation: boolean\n}\n\n// Keys in this object are used to filter out handbook options\n// before compiler options are set.\n\nconst defaultHandbookOptions: Partial<ExampleOptions> = {\n  errors: [],\n  noErrors: false,\n  showEmit: false,\n  showEmittedFile: undefined,\n  noStaticSemanticInfo: false,\n  emit: false,\n  noErrorValidation: false,\n}\n\nfunction filterHandbookOptions(codeLines: string[]): ExampleOptions {\n  const options: any = { ...defaultHandbookOptions }\n  for (let i = 0; i < codeLines.length; i++) {\n    let match\n    if ((match = booleanConfigRegexp.exec(codeLines[i]))) {\n      if (match[1] in options) {\n        options[match[1]] = true\n        log(`Setting options.${match[1]} to true`)\n        codeLines.splice(i, 1)\n        i--\n      }\n    } else if ((match = valuedConfigRegexp.exec(codeLines[i]))) {\n      if (match[1] in options) {\n        options[match[1]] = match[2]\n        log(`Setting options.${match[1]} to ${match[2]}`)\n        codeLines.splice(i, 1)\n        i--\n      }\n    }\n  }\n\n  // Edge case the errors object to turn it into a string array\n  if (\"errors\" in options && typeof options.errors === \"string\") {\n    options.errors = options.errors.split(\" \").map(Number)\n    log(\"Setting options.error to \", options.errors)\n  }\n\n  return options\n}\n\nexport interface TwoSlashReturn {\n  /** The output code, could be TypeScript, but could also be a JS/JSON/d.ts */\n  code: string\n\n  /** The new extension type for the code, potentially changed if they've requested emitted results */\n  extension: string\n\n  /** Requests to highlight a particular part of the code */\n  highlights: {\n    kind: \"highlight\"\n    /** The index of the text in the file */\n    start: number\n    /** What line is the highlighted identifier on? */\n    line: number\n    /** At what index in the line does the caret represent  */\n    offset: number\n    /** The text of the token which is highlighted */\n    text?: string\n    /** The length of the token */\n    length: number\n  }[]\n\n  /** An array of LSP responses identifiers in the sample  */\n  staticQuickInfos: {\n    /** The string content of the node this represents (mainly for debugging) */\n    targetString: string\n    /** The base LSP response (the type) */\n    text: string\n    /** Attached JSDoc info */\n    docs: string | undefined\n    /** The index of the text in the file */\n    start: number\n    /** how long the identifier */\n    length: number\n    /** line number where this is found */\n    line: number\n    /** The character on the line */\n    character: number\n  }[]\n\n  /** Requests to use the LSP to get info for a particular symbol in the source */\n  queries: {\n    kind: \"query\" | \"completions\"\n    /** What line is the highlighted identifier on? */\n    line: number\n    /** At what index in the line does the caret represent  */\n    offset: number\n    /** The text of the token which is highlighted */\n    text?: string\n    /** Any attached JSDocs */\n    docs?: string | undefined\n    /** The token start which the query indicates  */\n    start: number\n    /** The length of the token */\n    length: number\n    /** Results for completions at a particular point */\n    completions?: import(\"typescript\").CompletionEntry[]\n    /* Completion prefix e.g. the letters before the cursor in the word so you can filter */\n    completionsPrefix?: string\n  }[]\n\n  /** The extracted twoslash commands for any custom tags passed in via customTags */\n  tags: {\n    /** What was the name of the tag */\n    name: string\n    /** Where was it located in the original source file */\n    line: number\n    /** What was the text after the `// @tag: ` string  (optional because you could do // @tag on it's own line without the ':') */\n    annotation?: string\n  }[]\n\n  /** Diagnostic error messages which came up when creating the program */\n  errors: {\n    renderedMessage: string\n    id: string\n    category: 0 | 1 | 2 | 3\n    code: number\n    start: number | undefined\n    length: number | undefined\n    line: number | undefined\n    character: number | undefined\n  }[]\n\n  /** The URL for this sample in the playground */\n  playgroundURL: string\n}\n\nexport interface TwoSlashOptions {\n  /** Allows setting any of the handbook options from outside the function, useful if you don't want LSP identifiers */\n  defaultOptions?: Partial<ExampleOptions>\n\n  /** Allows setting any of the compiler options from outside the function */\n  defaultCompilerOptions?: CompilerOptions\n\n  /** Allows applying custom transformers to the emit result, only useful with the showEmit output */\n  customTransformers?: CustomTransformers\n\n  /** An optional copy of the TypeScript import, if missing it will be require'd. */\n  tsModule?: TS\n\n  /** An optional copy of the lz-string import, if missing it will be require'd. */\n  lzstringModule?: LZ\n\n  /**\n   * An optional Map object which is passed into @typescript/vfs - if you are using twoslash on the\n   * web then you'll need this to set up your lib *.d.ts files. If missing, it will use your fs.\n   */\n  fsMap?: Map<string, string>\n\n  /** The cwd for the folder which the virtual fs should be overlaid on top of when using local fs, opts to process.cwd() if not present */\n  vfsRoot?: string\n\n  /** A set of known `// @[tags]` tags to extract and not treat as a comment */\n  customTags?: string[]\n}\n\n/**\n * Runs the checker against a TypeScript/JavaScript code sample returning potentially\n * difference code, and a set of annotations around how it works.\n *\n * @param code The twoslash markup'd code\n * @param extension For example: \"ts\", \"tsx\", \"typescript\", \"javascript\" or \"js\".\n * @param options Additional options for twoslash\n */\nexport function twoslasher(code: string, extension: string, options: TwoSlashOptions = {}): TwoSlashReturn {\n  const ts: TS = options.tsModule ?? require(\"typescript\")\n  const lzstring: LZ = options.lzstringModule ?? require(\"lz-string\")\n\n  const originalCode = code\n  const safeExtension = typesToExtension(extension)\n  const defaultFileName = \"index.\" + safeExtension\n\n  log(`\\n\\nLooking at code: \\n\\`\\`\\`${safeExtension}\\n${code}\\n\\`\\`\\`\\n`)\n\n  const defaultCompilerOptions = {\n    strict: true,\n    target: ts.ScriptTarget.ES2016,\n    allowJs: true,\n    ...(options.defaultCompilerOptions ?? {}),\n  }\n\n  validateInput(code)\n\n  code = cleanMarkdownEscaped(code)\n\n  // NOTE: codeLines is mutated by the below functions:\n  const codeLines = code.split(/\\r\\n?|\\n/g)\n\n  let tags: TwoSlashReturn[\"tags\"] = options.customTags ? filterCustomTags(codeLines, options.customTags) : []\n  const handbookOptions = { ...filterHandbookOptions(codeLines), ...options.defaultOptions }\n  const compilerOptions = filterCompilerOptions(codeLines, defaultCompilerOptions, ts)\n\n  // Handle special casing the lookup for when using jsx preserve which creates .jsx files\n  if (!handbookOptions.showEmittedFile) {\n    handbookOptions.showEmittedFile =\n      compilerOptions.jsx && compilerOptions.jsx === ts.JsxEmit.Preserve ? \"index.jsx\" : \"index.js\"\n  }\n\n  const getRoot = () => {\n    const pa = \"pa\"\n    const path = require(pa + \"th\") as typeof import(\"path\")\n    const rootPath = options.vfsRoot || process.cwd()\n    return rootPath.split(path.sep).join(path.posix.sep)\n  }\n\n  // In a browser we want to DI everything, in node we can use local infra\n  const useFS = !!options.fsMap\n  const vfs = useFS && options.fsMap ? options.fsMap : new Map<string, string>()\n  const system = useFS ? createSystem(vfs) : createFSBackedSystem(vfs, getRoot(), ts)\n  const fsRoot = useFS ? \"/\" : getRoot() + \"/\"\n\n  const env = createVirtualTypeScriptEnvironment(system, [], ts, compilerOptions, options.customTransformers)\n  const ls = env.languageService\n\n  code = codeLines.join(\"\\n\")\n\n  let partialQueries = [] as (PartialQueryResults | PartialCompletionResults)[]\n  let queries = [] as TwoSlashReturn[\"queries\"]\n  let highlights = [] as TwoSlashReturn[\"highlights\"]\n\n  const nameContent = splitTwoslashCodeInfoFiles(code, defaultFileName, fsRoot)\n  const sourceFiles = [\"js\", \"jsx\", \"ts\", \"tsx\"]\n\n  /** All of the referenced files in the markup */\n  const filenames = nameContent.map(nc => nc[0])\n\n  for (const file of nameContent) {\n    const [filename, codeLines] = file\n    const filetype = filename.split(\".\").pop() || \"\"\n\n    // Only run the LSP-y things on source files\n    const allowJSON = compilerOptions.resolveJsonModule && filetype === \"json\"\n    if (!sourceFiles.includes(filetype) && !allowJSON) {\n      continue\n    }\n\n    // Create the file in the vfs\n    const newFileCode = codeLines.join(\"\\n\")\n    env.createFile(filename, newFileCode)\n\n    const updates = filterHighlightLines(codeLines)\n    highlights = highlights.concat(updates.highlights)\n\n    // ------ Do the LSP lookup for the queries\n\n    const lspedQueries = updates.queries.map((q, i) => {\n      const sourceFile = env.getSourceFile(filename)!\n      const position = ts.getPositionOfLineAndCharacter(sourceFile, q.line, q.offset)\n      switch (q.kind) {\n        case \"query\": {\n          const quickInfo = ls.getQuickInfoAtPosition(filename, position)\n\n          // prettier-ignore\n          let text: string\n          let docs: string | undefined\n\n          if (quickInfo && quickInfo.displayParts) {\n            text = quickInfo.displayParts.map(dp => dp.text).join(\"\")\n            docs = quickInfo.documentation ? quickInfo.documentation.map(d => d.text).join(\"<br/>\") : undefined\n          } else {\n            throw new TwoslashError(\n              `Invalid QuickInfo query`,\n              `The request on line ${q.line} in ${filename} for quickinfo via ^? returned no from the compiler.`,\n              `This is likely that the x positioning is off.`\n            )\n          }\n\n          const queryResult: PartialQueryResults = {\n            kind: \"query\",\n            text,\n            docs,\n            line: q.line - i,\n            offset: q.offset,\n            file: filename,\n          }\n          return queryResult\n        }\n\n        case \"completion\": {\n          const completions = ls.getCompletionsAtPosition(filename, position - 1, {})\n          if (!completions && !handbookOptions.noErrorValidation) {\n            throw new TwoslashError(\n              `Invalid completion query`,\n              `The request on line ${q.line} in ${filename} for completions via ^| returned no completions from the compiler.`,\n              `This is likely that the positioning is off.`\n            )\n          }\n\n          const word = getClosestWord(sourceFile.text, position - 1)\n          const prefix = sourceFile.text.slice(word.startPos, position)\n          const lastDot = prefix.split(\".\").pop() || \"\"\n\n          const queryResult: PartialCompletionResults = {\n            kind: \"completions\",\n            completions: completions?.entries || [],\n            completionPrefix: lastDot,\n            line: q.line - i,\n            offset: q.offset,\n            file: filename,\n          }\n          return queryResult\n        }\n      }\n    })\n    partialQueries = partialQueries.concat(lspedQueries)\n\n    // Sets the file in the compiler as being without the comments\n    const newEditedFileCode = codeLines.join(\"\\n\")\n    env.updateFile(filename, newEditedFileCode)\n  }\n\n  // We need to also strip the highlights + queries from the main file which is shown to people\n  const allCodeLines = code.split(/\\r\\n?|\\n/g)\n  filterHighlightLines(allCodeLines)\n  code = allCodeLines.join(\"\\n\")\n\n  // Lets fs changes propagate back up to the fsMap\n  if (handbookOptions.emit) {\n    filenames.forEach(f => {\n      const filetype = f.split(\".\").pop() || \"\"\n      if (!sourceFiles.includes(filetype)) return\n\n      const output = ls.getEmitOutput(f)\n      output.outputFiles.forEach(output => {\n        system.writeFile(output.name, output.text)\n      })\n    })\n  }\n\n  // Code should now be safe to compile, so we're going to split it into different files\n  let errs: import(\"typescript\").Diagnostic[] = []\n  // Let because of a filter when cutting\n  let staticQuickInfos: TwoSlashReturn[\"staticQuickInfos\"] = []\n\n  // Iterate through the declared files and grab errors and LSP quickinfos\n  // const declaredFiles = Object.keys(fileMap)\n\n  filenames.forEach(file => {\n    const filetype = file.split(\".\").pop() || \"\"\n\n    // Only run the LSP-y things on source files\n    if (!sourceFiles.includes(filetype)) {\n      return\n    }\n\n    if (!handbookOptions.noErrors) {\n      errs = errs.concat(ls.getSemanticDiagnostics(file), ls.getSyntacticDiagnostics(file))\n    }\n\n    const source = env.sys.readFile(file)!\n    const sourceFile = env.getSourceFile(file)\n    if (!sourceFile) {\n      throw new TwoslashError(\n        `Could not find a  TypeScript sourcefile for '${file}' in the Twoslash vfs`,\n        `It's a little hard to provide useful advice on this error. Maybe you imported something which the compiler doesn't think is a source file?`,\n        ``\n      )\n    }\n\n    // Get all of the interesting quick info popover\n    if (!handbookOptions.showEmit) {\n      const fileContentStartIndexInModifiedFile = code.indexOf(source) == -1 ? 0 : code.indexOf(source)\n      const linesAbove = code.slice(0, fileContentStartIndexInModifiedFile).split(\"\\n\").length - 1\n\n      // Get all interesting identifiers in the file, so we can show hover info for it\n      const identifiers = handbookOptions.noStaticSemanticInfo ? [] : getIdentifierTextSpans(ts, sourceFile)\n      for (const identifier of identifiers) {\n        const span = identifier.span\n        const quickInfo = ls.getQuickInfoAtPosition(file, span.start)\n\n        if (quickInfo && quickInfo.displayParts) {\n          const text = quickInfo.displayParts.map(dp => dp.text).join(\"\")\n          const targetString = identifier.text\n          const docs = quickInfo.documentation ? quickInfo.documentation.map(d => d.text).join(\"\\n\") : undefined\n\n          // Get the position of the\n          const position = span.start + fileContentStartIndexInModifiedFile\n          // Use TypeScript to pull out line/char from the original code at the position + any previous offset\n          const burnerSourceFile = ts.createSourceFile(\"_.ts\", code, ts.ScriptTarget.ES2015)\n          const { line, character } = ts.getLineAndCharacterOfPosition(burnerSourceFile, position)\n\n          staticQuickInfos.push({ text, docs, start: position, length: span.length, line, character, targetString })\n        }\n      }\n\n      // Offset the queries for this file because they are based on the line for that one\n      // specific file, and not the global twoslash document. This has to be done here because\n      // in the above loops, the code for queries/highlights/etc hasn't been stripped yet.\n      partialQueries\n        .filter((q: any) => q.file === file)\n        .forEach(q => {\n          const pos =\n            ts.getPositionOfLineAndCharacter(sourceFile, q.line, q.offset) + fileContentStartIndexInModifiedFile\n\n          switch (q.kind) {\n            case \"query\": {\n              queries.push({\n                docs: q.docs,\n                kind: \"query\",\n                start: pos + fileContentStartIndexInModifiedFile,\n                length: q.text.length,\n                text: q.text,\n                offset: q.offset,\n                line: q.line + linesAbove + 1,\n              })\n              break\n            }\n            case \"completions\": {\n              queries.push({\n                completions: q.completions,\n                kind: \"completions\",\n                start: pos + fileContentStartIndexInModifiedFile,\n                completionsPrefix: q.completionPrefix,\n                length: 1,\n                offset: q.offset,\n                line: q.line + linesAbove + 1,\n              })\n            }\n          }\n        })\n    }\n  })\n\n  const relevantErrors = errs.filter(e => e.file && filenames.includes(e.file.fileName))\n\n  // A validator that error codes are mentioned, so we can know if something has broken in the future\n  if (!handbookOptions.noErrorValidation && relevantErrors.length) {\n    validateCodeForErrors(relevantErrors, handbookOptions, extension, originalCode, fsRoot)\n  }\n\n  let errors: TwoSlashReturn[\"errors\"] = []\n\n  // We can't pass the ts.DiagnosticResult out directly (it can't be JSON.stringified)\n  for (const err of relevantErrors) {\n    const codeWhereErrorLives = env.sys.readFile(err.file!.fileName)!\n    const fileContentStartIndexInModifiedFile = code.indexOf(codeWhereErrorLives)\n    const renderedMessage = ts.flattenDiagnosticMessageText(err.messageText, \"\\n\")\n    const id = `err-${err.code}-${err.start}-${err.length}`\n    const { line, character } = ts.getLineAndCharacterOfPosition(err.file!, err.start!)\n\n    errors.push({\n      category: err.category,\n      code: err.code,\n      length: err.length,\n      start: err.start ? err.start + fileContentStartIndexInModifiedFile : undefined,\n      line,\n      character,\n      renderedMessage,\n      id,\n    })\n  }\n\n  // Handle emitting files\n  if (handbookOptions.showEmit) {\n    // Get the file which created the file we want to show:\n    const emitFilename = handbookOptions.showEmittedFile || defaultFileName\n    const emitSourceFilename =\n      fsRoot + emitFilename.replace(\".jsx\", \"\").replace(\".js\", \"\").replace(\".d.ts\", \"\").replace(\".map\", \"\")\n\n    let emitSource = filenames.find(f => f === emitSourceFilename + \".ts\" || f === emitSourceFilename + \".tsx\")\n\n    if (!emitSource && !compilerOptions.outFile) {\n      const allFiles = filenames.join(\", \")\n      // prettier-ignore\n      throw new TwoslashError(\n        `Could not find source file to show the emit for`,\n        `Cannot find the corresponding **source** file  ${emitFilename} for completions via ^| returned no quickinfo from the compiler.`,\n        `Looked for: ${emitSourceFilename} in the vfs - which contains: ${allFiles}`\n      )\n    }\n\n    // Allow outfile, in which case you need any file.\n    if (compilerOptions.outFile) {\n      emitSource = filenames[0]\n    }\n\n    const output = ls.getEmitOutput(emitSource!)\n    const file = output.outputFiles.find(\n      o => o.name === fsRoot + handbookOptions.showEmittedFile || o.name === handbookOptions.showEmittedFile\n    )\n\n    if (!file) {\n      const allFiles = output.outputFiles.map(o => o.name).join(\", \")\n      throw new TwoslashError(\n        `Cannot find the output file in the Twoslash VFS`,\n        `Looking for ${handbookOptions.showEmittedFile} in the Twoslash vfs after compiling`,\n        `Looked for\" ${fsRoot + handbookOptions.showEmittedFile} in the vfs - which contains ${allFiles}.`\n      )\n    }\n\n    code = file.text\n    extension = file.name.split(\".\").pop()!\n\n    // Remove highlights and queries, because it won't work across transpiles,\n    // though I guess source-mapping could handle the transition\n    highlights = []\n    partialQueries = []\n    staticQuickInfos = []\n  }\n\n  const zippedCode = lzstring.compressToEncodedURIComponent(originalCode)\n  const playgroundURL = `https://www.typescriptlang.org/play/#code/${zippedCode}`\n\n  // Cutting happens last, and it means editing the lines and character index of all\n  // the type annotations which are attached to a location\n\n  const cutString = \"// ---cut---\\n\"\n  if (code.includes(cutString)) {\n    // Get the place it is, then find the end and the start of the next line\n    const cutIndex = code.indexOf(cutString) + cutString.length\n    const lineOffset = code.substr(0, cutIndex).split(\"\\n\").length - 1\n\n    // Kills the code shown\n    code = code.split(cutString).pop()!\n\n    // For any type of metadata shipped, it will need to be shifted to\n    // fit in with the new positions after the cut\n    staticQuickInfos.forEach(info => {\n      info.start -= cutIndex\n      info.line -= lineOffset\n    })\n    staticQuickInfos = staticQuickInfos.filter(s => s.start > -1)\n\n    errors.forEach(err => {\n      if (err.start) err.start -= cutIndex\n      if (err.line) err.line -= lineOffset\n    })\n    errors = errors.filter(e => e.start && e.start > -1)\n\n    highlights.forEach(highlight => {\n      highlight.start -= cutIndex\n      highlight.line -= lineOffset\n    })\n\n    highlights = highlights.filter(e => e.start > -1)\n\n    queries.forEach(q => (q.line -= lineOffset))\n    queries = queries.filter(q => q.line > -1)\n\n    tags.forEach(q => (q.line -= lineOffset))\n    tags = tags.filter(q => q.line > -1)\n  }\n\n  const cutAfterString = \"// ---cut-after---\\n\"\n\n  if (code.includes(cutAfterString)) {\n    \n    // Get the place it is, then find the end and the start of the next line\n    const cutIndex = code.indexOf(cutAfterString) + cutAfterString.length\n    const lineOffset = code.substr(0, cutIndex).split(\"\\n\").length - 1\n\n    // Kills the code shown, removing any whitespace on the end\n    code = code.split(cutAfterString).shift()!.trimEnd()\n    \n    // Cut any metadata after the cutAfterString\n    staticQuickInfos = staticQuickInfos.filter(s => s.line < lineOffset)\n    errors = errors.filter(e => e.line && e.line < lineOffset)\n    highlights = highlights.filter(e => e.line < lineOffset)\n    queries = queries.filter(q => q.line < lineOffset)\n    tags = tags.filter(q => q.line < lineOffset)\n  }\n\n  return {\n    code,\n    extension,\n    highlights,\n    queries,\n    staticQuickInfos,\n    errors,\n    playgroundURL,\n    tags,\n  }\n}\n\nconst splitTwoslashCodeInfoFiles = (code: string, defaultFileName: string, root: string) => {\n  const lines = code.split(/\\r\\n?|\\n/g)\n\n  let nameForFile = code.includes(`@filename: ${defaultFileName}`) ? \"global.ts\" : defaultFileName\n  let currentFileContent: string[] = []\n  const fileMap: Array<[string, string[]]> = []\n\n  for (const line of lines) {\n    if (line.includes(\"// @filename: \")) {\n      fileMap.push([root + nameForFile, currentFileContent])\n      nameForFile = line.split(\"// @filename: \")[1].trim()\n      currentFileContent = []\n    } else {\n      currentFileContent.push(line)\n    }\n  }\n  fileMap.push([root + nameForFile, currentFileContent])\n\n  // Basically, strip these:\n  // [\"index.ts\", []]\n  // [\"index.ts\", [\"\"]]\n  const nameContent = fileMap.filter(n => n[1].length > 0 && (n[1].length > 1 || n[1][0] !== \"\"))\n  return nameContent\n}\n","import { TwoslashError } from \"./\"\n\n/** To ensure that errors are matched up right */\nexport function validateCodeForErrors(\n  relevantErrors: import(\"typescript\").Diagnostic[],\n  handbookOptions: { errors: number[] },\n  extension: string,\n  originalCode: string,\n  vfsRoot: string\n) {\n  const inErrsButNotFoundInTheHeader = relevantErrors.filter(e => !handbookOptions.errors.includes(e.code))\n  const errorsFound = Array.from(new Set(inErrsButNotFoundInTheHeader.map(e => e.code))).join(\" \")\n\n  if (inErrsButNotFoundInTheHeader.length) {\n    const errorsToShow = new Set(relevantErrors.map(e => e.code))\n    const codeToAdd = `// @errors: ${Array.from(errorsToShow).join(\" \")}`\n\n    const missing = handbookOptions.errors.length\n      ? `\\nThe existing annotation specified ${handbookOptions.errors.join(\" \")}`\n      : \"\\nExpected: \" + codeToAdd\n\n    // These get filled by below\n    const filesToErrors: Record<string, import(\"typescript\").Diagnostic[]> = {}\n    const noFiles: import(\"typescript\").Diagnostic[] = []\n\n    inErrsButNotFoundInTheHeader.forEach(d => {\n      const fileRef = d.file?.fileName && d.file.fileName.replace(vfsRoot, \"\")\n      if (!fileRef) noFiles.push(d)\n      else {\n        const existing = filesToErrors[fileRef]\n        if (existing) existing.push(d)\n        else filesToErrors[fileRef] = [d]\n      }\n    })\n\n    const showDiagnostics = (title: string, diags: import(\"typescript\").Diagnostic[]) => {\n      return (\n        `${title}\\n  ` +\n        diags\n          .map(e => {\n            const msg = typeof e.messageText === \"string\" ? e.messageText : e.messageText.messageText\n            return `[${e.code}] ${e.start} - ${msg}`\n          })\n          .join(\"\\n  \")\n      )\n    }\n\n    const innerDiags: string[] = []\n    if (noFiles.length) {\n      innerDiags.push(showDiagnostics(\"Ambient Errors\", noFiles))\n    }\n    Object.keys(filesToErrors).forEach(filepath => {\n      innerDiags.push(showDiagnostics(filepath, filesToErrors[filepath]))\n    })\n\n    const allMessages = innerDiags.join(\"\\n\\n\")\n\n    const newErr = new TwoslashError(\n      `Errors were thrown in the sample, but not included in an errors tag`,\n      `These errors were not marked as being expected: ${errorsFound}. ${missing}`,\n      `Compiler Errors:\\n\\n${allMessages}`\n    )\n\n    newErr.code = `## Code\\n\\n'''${extension}\\n${originalCode}\\n'''`\n    throw newErr\n  }\n}\n\n/** Mainly to warn myself, I've lost a good few minutes to this before */\nexport function validateInput(code: string) {\n  if (code.includes(\"// @errors \")) {\n    throw new TwoslashError(\n      `You have '// @errors ' (with a space)`,\n      `You want '// @errors: ' (with a colon)`,\n      `This is a pretty common typo`\n    )\n  }\n\n  if (code.includes(\"// @filename \")) {\n    throw new TwoslashError(\n      `You have '// @filename ' (with a space)`,\n      `You want '// @filename: ' (with a colon)`,\n      `This is a pretty common typo`\n    )\n  }\n}\n"],"names":["parsePrimitive","value","type","toLowerCase","length","TwoslashError","hasLocalStorage","localStorage","error","hasProcess","process","log","getItem","env","DEBUG","console","_message","title","description","recommendation","code","message","Error","filterHighlightLines","codeLines","highlights","queries","nextContentOffset","contentOffset","removedLines","line","i","moveForward","stripLine","logDesc","splice","includes","highlightMatch","exec","queryMatch","removePrettierIgnoreMatch","completionsQuery","start","indexOf","push","kind","offset","text","undefined","docs","lastIndexOf","trim","getOptionValueFromMap","name","key","optMap","result","get","keys","Array","from","join","setOption","opts","ts","opt","elementType","element","strings","split","map","v","optionDeclarations","booleanConfigRegexp","valuedConfigRegexp","defaultHandbookOptions","errors","noErrors","showEmit","showEmittedFile","noStaticSemanticInfo","emit","noErrorValidation","extension","options","tsModule","require","lzstring","lzstringModule","originalCode","safeExtension","types","js","javascript","typescript","tsx","jsx","json","jsn","Object","typesToExtension","defaultFileName","defaultCompilerOptions","strict","target","ScriptTarget","ES2016","allowJs","validateInput","replace","cleanMarkdownEscaped","tags","customTags","match","annotation","filterCustomTags","handbookOptions","Number","filterHandbookOptions","defaultOptions","compilerOptions","filterCompilerOptions","JsxEmit","Preserve","getRoot","path","pa","vfsRoot","cwd","sep","posix","useFS","fsMap","vfs","Map","system","createSystem","createFSBackedSystem","fsRoot","createVirtualTypeScriptEnvironment","customTransformers","ls","languageService","partialQueries","nameContent","root","lines","nameForFile","currentFileContent","fileMap","filter","n","splitTwoslashCodeInfoFiles","sourceFiles","filenames","nc","file","filename","filetype","pop","allowJSON","resolveJsonModule","newFileCode","createFile","updates","concat","lspedQueries","q","sourceFile","getSourceFile","position","getPositionOfLineAndCharacter","quickInfo","getQuickInfoAtPosition","displayParts","dp","documentation","d","completions","getCompletionsAtPosition","word","str","pos","String","left","slice","search","right","startPos","getClosestWord","lastDot","entries","completionPrefix","newEditedFileCode","updateFile","allCodeLines","forEach","f","getEmitOutput","outputFiles","output","writeFile","errs","staticQuickInfos","getSemanticDiagnostics","getSyntacticDiagnostics","source","sys","readFile","fileContentStartIndexInModifiedFile","linesAbove","textSpans","checkChildren","node","forEachChild","child","isIdentifier","getStart","span","createTextSpan","end","getText","getIdentifierTextSpans","identifier","targetString","burnerSourceFile","createSourceFile","ES2015","getLineAndCharacterOfPosition","character","completionsPrefix","relevantErrors","e","fileName","inErrsButNotFoundInTheHeader","errorsFound","Set","errorsToShow","codeToAdd","missing","filesToErrors","noFiles","fileRef","existing","showDiagnostics","diags","messageText","innerDiags","filepath","allMessages","newErr","validateCodeForErrors","err","codeWhereErrorLives","renderedMessage","flattenDiagnosticMessageText","id","category","emitFilename","emitSourceFilename","emitSource","find","outFile","allFiles","o","playgroundURL","compressToEncodedURIComponent","cutString","cutIndex","lineOffset","substr","info","s","highlight","shift","trimEnd"],"mappings":"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"}