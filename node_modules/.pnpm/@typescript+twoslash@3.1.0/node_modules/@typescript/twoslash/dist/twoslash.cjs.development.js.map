{"version":3,"file":"twoslash.cjs.development.js","sources":["../src/utils.ts","../src/validation.ts","../src/index.ts"],"sourcesContent":["import { TwoslashError } from \"./\"\n\nexport function escapeHtml(text: string) {\n  return text.replace(/</g, \"&lt;\")\n}\n\nexport function strrep(text: string, count: number) {\n  let s = \"\"\n  for (let i = 0; i < count; i++) {\n    s += text\n  }\n  return s\n}\n\nexport function textToAnchorName(text: string) {\n  return text\n    .toLowerCase()\n    .replace(/ /g, \"-\")\n    .replace(/`|#|\\//g, \"\")\n}\n\nexport function fileNameToUrlName(s: string) {\n  return s.replace(/ /g, \"-\").replace(/#/g, \"sharp\").toLowerCase()\n}\n\nexport function parsePrimitive(value: string, type: string): any {\n  switch (type) {\n    case \"number\":\n      return +value\n    case \"string\":\n      return value\n    case \"boolean\":\n      return value.toLowerCase() === \"true\" || value.length === 0\n  }\n\n  throw new TwoslashError(\n    `Unknown primitive value in compiler flag`,\n    `The only recognized primitives are number, string and boolean. Got ${type} with ${value}.`,\n    `This is likely a typo.`\n  )\n}\n\nexport function cleanMarkdownEscaped(code: string) {\n  code = code.replace(/¨D/g, \"$\")\n  code = code.replace(/¨T/g, \"~\")\n  return code\n}\n\nexport function typesToExtension(types: string) {\n  const map: Record<string, string> = {\n    js: \"js\",\n    javascript: \"js\",\n    ts: \"ts\",\n    typescript: \"ts\",\n    tsx: \"tsx\",\n    jsx: \"jsx\",\n    json: \"json\",\n    jsn: \"json\",\n  }\n\n  if (map[types]) return map[types]\n\n  throw new TwoslashError(\n    `Unknown TypeScript extension given to Twoslash`,\n    `Received ${types} but Twoslash only accepts: ${Object.keys(map)} `,\n    ``\n  )\n}\n\nexport function getIdentifierTextSpans(ts: typeof import(\"typescript\"), sourceFile: import(\"typescript\").SourceFile) {\n  const textSpans: { span: import(\"typescript\").TextSpan; text: string }[] = []\n  checkChildren(sourceFile)\n  return textSpans\n\n  function checkChildren(node: import(\"typescript\").Node) {\n    ts.forEachChild(node, child => {\n      if (ts.isIdentifier(child)) {\n        const start = child.getStart(sourceFile, false)\n        textSpans.push({ span: ts.createTextSpan(start, child.end - start), text: child.getText(sourceFile) })\n      }\n      checkChildren(child)\n    })\n  }\n}\n\nexport function stringAroundIndex(string: string, index: number) {\n  const arr = [\n    string[index - 3],\n    string[index - 2],\n    string[index - 1],\n    \">\",\n    string[index],\n    \"<\",\n    string[index + 1],\n    string[index + 2],\n    string[index + 3],\n  ]\n  return arr.filter(Boolean).join(\"\")\n}\n\n/** Came from https://ourcodeworld.com/articles/read/223/how-to-retrieve-the-closest-word-in-a-string-with-a-given-index-in-javascript */\nexport function getClosestWord(str: string, pos: number) {\n  // Make copies\n  str = String(str)\n  pos = Number(pos) >>> 0\n\n  // Search for the word's beginning and end.\n  var left = str.slice(0, pos + 1).search(/\\S+$/),\n    right = str.slice(pos).search(/\\s/)\n\n  // The last word in the string is a special case.\n  if (right < 0) {\n    return {\n      word: str.slice(left),\n      startPos: left,\n    }\n  }\n  // Return the word, using the located bounds to extract it from the string.\n  return {\n    word: str.slice(left, right + pos),\n    startPos: left,\n  }\n}\n","import { TwoslashError } from \"./\"\n\n/** To ensure that errors are matched up right */\nexport function validateCodeForErrors(\n  relevantErrors: import(\"typescript\").Diagnostic[],\n  handbookOptions: { errors: number[] },\n  extension: string,\n  originalCode: string,\n  vfsRoot: string\n) {\n  const inErrsButNotFoundInTheHeader = relevantErrors.filter(e => !handbookOptions.errors.includes(e.code))\n  const errorsFound = Array.from(new Set(inErrsButNotFoundInTheHeader.map(e => e.code))).join(\" \")\n\n  if (inErrsButNotFoundInTheHeader.length) {\n    const errorsToShow = new Set(relevantErrors.map(e => e.code))\n    const codeToAdd = `// @errors: ${Array.from(errorsToShow).join(\" \")}`\n\n    const missing = handbookOptions.errors.length\n      ? `\\nThe existing annotation specified ${handbookOptions.errors.join(\" \")}`\n      : \"\\nExpected: \" + codeToAdd\n\n    // These get filled by below\n    const filesToErrors: Record<string, import(\"typescript\").Diagnostic[]> = {}\n    const noFiles: import(\"typescript\").Diagnostic[] = []\n\n    inErrsButNotFoundInTheHeader.forEach(d => {\n      const fileRef = d.file?.fileName && d.file.fileName.replace(vfsRoot, \"\")\n      if (!fileRef) noFiles.push(d)\n      else {\n        const existing = filesToErrors[fileRef]\n        if (existing) existing.push(d)\n        else filesToErrors[fileRef] = [d]\n      }\n    })\n\n    const showDiagnostics = (title: string, diags: import(\"typescript\").Diagnostic[]) => {\n      return (\n        `${title}\\n  ` +\n        diags\n          .map(e => {\n            const msg = typeof e.messageText === \"string\" ? e.messageText : e.messageText.messageText\n            return `[${e.code}] ${e.start} - ${msg}`\n          })\n          .join(\"\\n  \")\n      )\n    }\n\n    const innerDiags: string[] = []\n    if (noFiles.length) {\n      innerDiags.push(showDiagnostics(\"Ambient Errors\", noFiles))\n    }\n    Object.keys(filesToErrors).forEach(filepath => {\n      innerDiags.push(showDiagnostics(filepath, filesToErrors[filepath]))\n    })\n\n    const allMessages = innerDiags.join(\"\\n\\n\")\n\n    const newErr = new TwoslashError(\n      `Errors were thrown in the sample, but not included in an errors tag`,\n      `These errors were not marked as being expected: ${errorsFound}. ${missing}`,\n      `Compiler Errors:\\n\\n${allMessages}`\n    )\n\n    newErr.code = `## Code\\n\\n'''${extension}\\n${originalCode}\\n'''`\n    throw newErr\n  }\n}\n\n/** Mainly to warn myself, I've lost a good few minutes to this before */\nexport function validateInput(code: string) {\n  if (code.includes(\"// @errors \")) {\n    throw new TwoslashError(\n      `You have '// @errors ' (with a space)`,\n      `You want '// @errors: ' (with a colon)`,\n      `This is a pretty common typo`\n    )\n  }\n\n  if (code.includes(\"// @filename \")) {\n    throw new TwoslashError(\n      `You have '// @filename ' (with a space)`,\n      `You want '// @filename: ' (with a colon)`,\n      `This is a pretty common typo`\n    )\n  }\n}\n","let hasLocalStorage = false\ntry {\n  hasLocalStorage = typeof localStorage !== `undefined`\n} catch (error) {}\nconst hasProcess = typeof process !== `undefined`\nconst shouldDebug = (hasLocalStorage && localStorage.getItem(\"DEBUG\")) || (hasProcess && process.env.DEBUG)\n\ntype LZ = typeof import(\"lz-string\")\ntype TS = typeof import(\"typescript\")\ntype CompilerOptions = import(\"typescript\").CompilerOptions\ntype CustomTransformers = import(\"typescript\").CustomTransformers\n\nimport { parsePrimitive, cleanMarkdownEscaped, typesToExtension, getIdentifierTextSpans, getClosestWord } from \"./utils\"\nimport { validateInput, validateCodeForErrors } from \"./validation\"\n\nimport { createSystem, createVirtualTypeScriptEnvironment, createFSBackedSystem } from \"@typescript/vfs\"\n\nconst log = shouldDebug ? console.log : (_message?: any, ..._optionalParams: any[]) => \"\"\n\n// Hacking in some internal stuff\ndeclare module \"typescript\" {\n  type Option = {\n    name: string\n    type: \"list\" | \"boolean\" | \"number\" | \"string\" | import(\"typescript\").Map<any>\n    element?: Option\n  }\n\n  const optionDeclarations: Array<Option>\n}\n\ntype QueryPosition = {\n  kind: \"query\" | \"completion\"\n  offset: number\n  text: string | undefined\n  docs: string | undefined\n  line: number\n}\n\ntype PartialQueryResults = {\n  kind: \"query\"\n  text: string\n  docs: string | undefined\n  line: number\n  offset: number\n  file: string\n}\n\ntype PartialCompletionResults = {\n  kind: \"completions\"\n  completions: import(\"typescript\").CompletionEntry[]\n  completionPrefix: string\n\n  line: number\n  offset: number\n  file: string\n}\n\ntype HighlightPosition = TwoSlashReturn[\"highlights\"][number]\n\nexport class TwoslashError extends Error {\n  public title: string\n  public description: string\n  public recommendation: string\n  public code: string | undefined\n\n  constructor(title: string, description: string, recommendation: string, code?: string | undefined) {\n    let message = `\n## ${title}\n\n${description}\n`\n    if (recommendation) {\n      message += `\\n${recommendation}`\n    }\n\n    if (code) {\n      message += `\\n${code}`\n    }\n\n    super(message)\n    this.title = title\n    this.description = description\n    this.recommendation = recommendation\n    this.code = code\n  }\n}\n\nfunction filterHighlightLines(codeLines: string[]): { highlights: HighlightPosition[]; queries: QueryPosition[] } {\n  const highlights: HighlightPosition[] = []\n  const queries: QueryPosition[] = []\n\n  let nextContentOffset = 0\n  let contentOffset = 0\n  let removedLines = 0\n\n  for (let i = 0; i < codeLines.length; i++) {\n    const line = codeLines[i]\n    const moveForward = () => {\n      contentOffset = nextContentOffset\n      nextContentOffset += line.length + 1\n    }\n\n    const stripLine = (logDesc: string) => {\n      log(`Removing line ${i} for ${logDesc}`)\n\n      removedLines++\n      codeLines.splice(i, 1)\n      i--\n    }\n\n    // We only need to run regexes over lines with comments\n    if (!line.includes(\"//\")) {\n      moveForward()\n    } else {\n      const highlightMatch = /^\\s*\\/\\/\\s*\\^+( .+)?$/.exec(line)\n      const queryMatch = /^\\s*\\/\\/\\s*\\^\\?\\s*$/.exec(line)\n      // https://regex101.com/r/2yDsRk/1\n      const removePrettierIgnoreMatch = /^\\s*\\/\\/ prettier-ignore$/.exec(line)\n      const completionsQuery = /^\\s*\\/\\/\\s*\\^\\|$/.exec(line)\n\n      if (queryMatch !== null) {\n        const start = line.indexOf(\"^\")\n        queries.push({ kind: \"query\", offset: start, text: undefined, docs: undefined, line: i + removedLines - 1 })\n        stripLine(\"having a query\")\n      } else if (highlightMatch !== null) {\n        const start = line.indexOf(\"^\")\n        const length = line.lastIndexOf(\"^\") - start + 1\n        const description = highlightMatch[1] ? highlightMatch[1].trim() : \"\"\n        highlights.push({\n          kind: \"highlight\",\n          offset: start + contentOffset,\n          length,\n          text: description,\n          line: i + removedLines - 1,\n          start,\n        })\n\n        stripLine(\"having a highlight\")\n      } else if (removePrettierIgnoreMatch !== null) {\n        stripLine(\"being a prettier ignore\")\n      } else if (completionsQuery !== null) {\n        const start = line.indexOf(\"^\")\n        // prettier-ignore\n        queries.push({ kind: \"completion\", offset: start, text: undefined, docs: undefined, line: i + removedLines - 1 })\n        stripLine(\"having a completion query\")\n      } else {\n        moveForward()\n      }\n    }\n  }\n  return { highlights, queries }\n}\n\nfunction getOptionValueFromMap(name: string, key: string, optMap: Map<string, string>) {\n  const result = optMap.get(key.toLowerCase())\n  log(`Get ${name} mapped option: ${key} => ${result}`)\n  if (result === undefined) {\n    const keys = Array.from(optMap.keys() as any)\n\n    throw new TwoslashError(\n      `Invalid inline compiler value`,\n      `Got ${key} for ${name} but it is not a supported value by the TS compiler.`,\n      `Allowed values: ${keys.join(\",\")}`\n    )\n  }\n  return result\n}\n\nfunction setOption(name: string, value: string, opts: CompilerOptions, ts: TS) {\n  log(`Setting ${name} to ${value}`)\n\n  for (const opt of ts.optionDeclarations) {\n    if (opt.name.toLowerCase() === name.toLowerCase()) {\n      switch (opt.type) {\n        case \"number\":\n        case \"string\":\n        case \"boolean\":\n          opts[opt.name] = parsePrimitive(value, opt.type)\n          break\n\n        case \"list\":\n          const elementType = opt.element!.type\n          const strings = value.split(\",\")\n          if (typeof elementType === \"string\") {\n            opts[opt.name] = strings.map(v => parsePrimitive(v, elementType))\n          } else {\n            opts[opt.name] = strings.map(v => getOptionValueFromMap(opt.name, v, elementType as Map<string, string>))\n          }\n          break\n\n        default:\n          // It's a map!\n          const optMap = opt.type as Map<string, string>\n          opts[opt.name] = getOptionValueFromMap(opt.name, value, optMap)\n          break\n      }\n      return\n    }\n  }\n\n  throw new TwoslashError(\n    `Invalid inline compiler flag`,\n    `There isn't a TypeScript compiler flag called '${name}'.`,\n    `This is likely a typo, you can check all the compiler flags in the TSConfig reference, or check the additional Twoslash flags in the npm page for @typescript/twoslash.`\n  )\n}\n\nconst booleanConfigRegexp = /^\\/\\/\\s?@(\\w+)$/\n\n// https://regex101.com/r/8B2Wwh/1\nconst valuedConfigRegexp = /^\\/\\/\\s?@(\\w+):\\s?(.+)$/\n\nfunction filterCompilerOptions(codeLines: string[], defaultCompilerOptions: CompilerOptions, ts: TS) {\n  const options = { ...defaultCompilerOptions }\n  for (let i = 0; i < codeLines.length; ) {\n    let match\n    if ((match = booleanConfigRegexp.exec(codeLines[i]))) {\n      options[match[1]] = true\n      setOption(match[1], \"true\", options, ts)\n    } else if ((match = valuedConfigRegexp.exec(codeLines[i]))) {\n      // Skip a filename tag, which should propagate through this stage\n      if (match[1] === \"filename\") {\n        i++\n        continue\n      }\n      setOption(match[1], match[2], options, ts)\n    } else {\n      i++\n      continue\n    }\n    codeLines.splice(i, 1)\n  }\n  return options\n}\n\nfunction filterCustomTags(codeLines: string[], customTags: string[]) {\n  const tags: TwoSlashReturn[\"tags\"] = []\n\n  for (let i = 0; i < codeLines.length; ) {\n    let match\n    if ((match = valuedConfigRegexp.exec(codeLines[i]))) {\n      if (customTags.includes(match[1])) {\n        tags.push({ name: match[1], line: i, annotation: codeLines[i].split(\"@\" + match[1] + \": \")[1] })\n        codeLines.splice(i, 1)\n      }\n    }\n    i++\n  }\n  return tags\n}\n\n/** Available inline flags which are not compiler flags */\nexport interface ExampleOptions {\n  /** Lets the sample suppress all error diagnostics */\n  noErrors: boolean\n  /** An array of TS error codes, which you write as space separated - this is so the tool can know about unexpected errors */\n  errors: number[]\n  /** Shows the JS equivalent of the TypeScript code instead */\n  showEmit: boolean\n  /**\n   * Must be used with showEmit, lets you choose the file to present instead of the source - defaults to index.js which\n   * means when you just use `showEmit` above it shows the transpiled JS.\n   */\n  showEmittedFile: string\n\n  /** Whether to disable the pre-cache of LSP calls for interesting identifiers, defaults to false */\n  noStaticSemanticInfo: boolean\n  /** Declare that the TypeScript program should edit the fsMap which is passed in, this is only useful for tool-makers, defaults to false */\n  emit: boolean\n  /** Declare that you don't need to validate that errors have corresponding annotations, defaults to false */\n  noErrorValidation: boolean\n}\n\n// Keys in this object are used to filter out handbook options\n// before compiler options are set.\n\nconst defaultHandbookOptions: Partial<ExampleOptions> = {\n  errors: [],\n  noErrors: false,\n  showEmit: false,\n  showEmittedFile: undefined,\n  noStaticSemanticInfo: false,\n  emit: false,\n  noErrorValidation: false,\n}\n\nfunction filterHandbookOptions(codeLines: string[]): ExampleOptions {\n  const options: any = { ...defaultHandbookOptions }\n  for (let i = 0; i < codeLines.length; i++) {\n    let match\n    if ((match = booleanConfigRegexp.exec(codeLines[i]))) {\n      if (match[1] in options) {\n        options[match[1]] = true\n        log(`Setting options.${match[1]} to true`)\n        codeLines.splice(i, 1)\n        i--\n      }\n    } else if ((match = valuedConfigRegexp.exec(codeLines[i]))) {\n      if (match[1] in options) {\n        options[match[1]] = match[2]\n        log(`Setting options.${match[1]} to ${match[2]}`)\n        codeLines.splice(i, 1)\n        i--\n      }\n    }\n  }\n\n  // Edge case the errors object to turn it into a string array\n  if (\"errors\" in options && typeof options.errors === \"string\") {\n    options.errors = options.errors.split(\" \").map(Number)\n    log(\"Setting options.error to \", options.errors)\n  }\n\n  return options\n}\n\nexport interface TwoSlashReturn {\n  /** The output code, could be TypeScript, but could also be a JS/JSON/d.ts */\n  code: string\n\n  /** The new extension type for the code, potentially changed if they've requested emitted results */\n  extension: string\n\n  /** Requests to highlight a particular part of the code */\n  highlights: {\n    kind: \"highlight\"\n    /** The index of the text in the file */\n    start: number\n    /** What line is the highlighted identifier on? */\n    line: number\n    /** At what index in the line does the caret represent  */\n    offset: number\n    /** The text of the token which is highlighted */\n    text?: string\n    /** The length of the token */\n    length: number\n  }[]\n\n  /** An array of LSP responses identifiers in the sample  */\n  staticQuickInfos: {\n    /** The string content of the node this represents (mainly for debugging) */\n    targetString: string\n    /** The base LSP response (the type) */\n    text: string\n    /** Attached JSDoc info */\n    docs: string | undefined\n    /** The index of the text in the file */\n    start: number\n    /** how long the identifier */\n    length: number\n    /** line number where this is found */\n    line: number\n    /** The character on the line */\n    character: number\n  }[]\n\n  /** Requests to use the LSP to get info for a particular symbol in the source */\n  queries: {\n    kind: \"query\" | \"completions\"\n    /** What line is the highlighted identifier on? */\n    line: number\n    /** At what index in the line does the caret represent  */\n    offset: number\n    /** The text of the token which is highlighted */\n    text?: string\n    /** Any attached JSDocs */\n    docs?: string | undefined\n    /** The token start which the query indicates  */\n    start: number\n    /** The length of the token */\n    length: number\n    /** Results for completions at a particular point */\n    completions?: import(\"typescript\").CompletionEntry[]\n    /* Completion prefix e.g. the letters before the cursor in the word so you can filter */\n    completionsPrefix?: string\n  }[]\n\n  /** The extracted twoslash commands for any custom tags passed in via customTags */\n  tags: {\n    /** What was the name of the tag */\n    name: string\n    /** Where was it located in the original source file */\n    line: number\n    /** What was the text after the `// @tag: ` string  (optional because you could do // @tag on it's own line without the ':') */\n    annotation?: string\n  }[]\n\n  /** Diagnostic error messages which came up when creating the program */\n  errors: {\n    renderedMessage: string\n    id: string\n    category: 0 | 1 | 2 | 3\n    code: number\n    start: number | undefined\n    length: number | undefined\n    line: number | undefined\n    character: number | undefined\n  }[]\n\n  /** The URL for this sample in the playground */\n  playgroundURL: string\n}\n\nexport interface TwoSlashOptions {\n  /** Allows setting any of the handbook options from outside the function, useful if you don't want LSP identifiers */\n  defaultOptions?: Partial<ExampleOptions>\n\n  /** Allows setting any of the compiler options from outside the function */\n  defaultCompilerOptions?: CompilerOptions\n\n  /** Allows applying custom transformers to the emit result, only useful with the showEmit output */\n  customTransformers?: CustomTransformers\n\n  /** An optional copy of the TypeScript import, if missing it will be require'd. */\n  tsModule?: TS\n\n  /** An optional copy of the lz-string import, if missing it will be require'd. */\n  lzstringModule?: LZ\n\n  /**\n   * An optional Map object which is passed into @typescript/vfs - if you are using twoslash on the\n   * web then you'll need this to set up your lib *.d.ts files. If missing, it will use your fs.\n   */\n  fsMap?: Map<string, string>\n\n  /** The cwd for the folder which the virtual fs should be overlaid on top of when using local fs, opts to process.cwd() if not present */\n  vfsRoot?: string\n\n  /** A set of known `// @[tags]` tags to extract and not treat as a comment */\n  customTags?: string[]\n}\n\n/**\n * Runs the checker against a TypeScript/JavaScript code sample returning potentially\n * difference code, and a set of annotations around how it works.\n *\n * @param code The twoslash markup'd code\n * @param extension For example: \"ts\", \"tsx\", \"typescript\", \"javascript\" or \"js\".\n * @param options Additional options for twoslash\n */\nexport function twoslasher(code: string, extension: string, options: TwoSlashOptions = {}): TwoSlashReturn {\n  const ts: TS = options.tsModule ?? require(\"typescript\")\n  const lzstring: LZ = options.lzstringModule ?? require(\"lz-string\")\n\n  const originalCode = code\n  const safeExtension = typesToExtension(extension)\n  const defaultFileName = \"index.\" + safeExtension\n\n  log(`\\n\\nLooking at code: \\n\\`\\`\\`${safeExtension}\\n${code}\\n\\`\\`\\`\\n`)\n\n  const defaultCompilerOptions = {\n    strict: true,\n    target: ts.ScriptTarget.ES2016,\n    allowJs: true,\n    ...(options.defaultCompilerOptions ?? {}),\n  }\n\n  validateInput(code)\n\n  code = cleanMarkdownEscaped(code)\n\n  // NOTE: codeLines is mutated by the below functions:\n  const codeLines = code.split(/\\r\\n?|\\n/g)\n\n  let tags: TwoSlashReturn[\"tags\"] = options.customTags ? filterCustomTags(codeLines, options.customTags) : []\n  const handbookOptions = { ...filterHandbookOptions(codeLines), ...options.defaultOptions }\n  const compilerOptions = filterCompilerOptions(codeLines, defaultCompilerOptions, ts)\n\n  // Handle special casing the lookup for when using jsx preserve which creates .jsx files\n  if (!handbookOptions.showEmittedFile) {\n    handbookOptions.showEmittedFile =\n      compilerOptions.jsx && compilerOptions.jsx === ts.JsxEmit.Preserve ? \"index.jsx\" : \"index.js\"\n  }\n\n  const getRoot = () => {\n    const pa = \"pa\"\n    const path = require(pa + \"th\") as typeof import(\"path\")\n    const rootPath = options.vfsRoot || process.cwd()\n    return rootPath.split(path.sep).join(path.posix.sep)\n  }\n\n  // In a browser we want to DI everything, in node we can use local infra\n  const useFS = !!options.fsMap\n  const vfs = useFS && options.fsMap ? options.fsMap : new Map<string, string>()\n  const system = useFS ? createSystem(vfs) : createFSBackedSystem(vfs, getRoot(), ts)\n  const fsRoot = useFS ? \"/\" : getRoot() + \"/\"\n\n  const env = createVirtualTypeScriptEnvironment(system, [], ts, compilerOptions, options.customTransformers)\n  const ls = env.languageService\n\n  code = codeLines.join(\"\\n\")\n\n  let partialQueries = [] as (PartialQueryResults | PartialCompletionResults)[]\n  let queries = [] as TwoSlashReturn[\"queries\"]\n  let highlights = [] as TwoSlashReturn[\"highlights\"]\n\n  const nameContent = splitTwoslashCodeInfoFiles(code, defaultFileName, fsRoot)\n  const sourceFiles = [\"js\", \"jsx\", \"ts\", \"tsx\"]\n\n  /** All of the referenced files in the markup */\n  const filenames = nameContent.map(nc => nc[0])\n\n  for (const file of nameContent) {\n    const [filename, codeLines] = file\n    const filetype = filename.split(\".\").pop() || \"\"\n\n    // Only run the LSP-y things on source files\n    const allowJSON = compilerOptions.resolveJsonModule && filetype === \"json\"\n    if (!sourceFiles.includes(filetype) && !allowJSON) {\n      continue\n    }\n\n    // Create the file in the vfs\n    const newFileCode = codeLines.join(\"\\n\")\n    env.createFile(filename, newFileCode)\n\n    const updates = filterHighlightLines(codeLines)\n    highlights = highlights.concat(updates.highlights)\n\n    // ------ Do the LSP lookup for the queries\n\n    const lspedQueries = updates.queries.map((q, i) => {\n      const sourceFile = env.getSourceFile(filename)!\n      const position = ts.getPositionOfLineAndCharacter(sourceFile, q.line, q.offset)\n      switch (q.kind) {\n        case \"query\": {\n          const quickInfo = ls.getQuickInfoAtPosition(filename, position)\n\n          // prettier-ignore\n          let text: string\n          let docs: string | undefined\n\n          if (quickInfo && quickInfo.displayParts) {\n            text = quickInfo.displayParts.map(dp => dp.text).join(\"\")\n            docs = quickInfo.documentation ? quickInfo.documentation.map(d => d.text).join(\"<br/>\") : undefined\n          } else {\n            throw new TwoslashError(\n              `Invalid QuickInfo query`,\n              `The request on line ${q.line} in ${filename} for quickinfo via ^? returned no from the compiler.`,\n              `This is likely that the x positioning is off.`\n            )\n          }\n\n          const queryResult: PartialQueryResults = {\n            kind: \"query\",\n            text,\n            docs,\n            line: q.line - i,\n            offset: q.offset,\n            file: filename,\n          }\n          return queryResult\n        }\n\n        case \"completion\": {\n          const completions = ls.getCompletionsAtPosition(filename, position - 1, {})\n          if (!completions && !handbookOptions.noErrorValidation) {\n            throw new TwoslashError(\n              `Invalid completion query`,\n              `The request on line ${q.line} in ${filename} for completions via ^| returned no completions from the compiler.`,\n              `This is likely that the positioning is off.`\n            )\n          }\n\n          const word = getClosestWord(sourceFile.text, position - 1)\n          const prefix = sourceFile.text.slice(word.startPos, position)\n          const lastDot = prefix.split(\".\").pop() || \"\"\n\n          const queryResult: PartialCompletionResults = {\n            kind: \"completions\",\n            completions: completions?.entries || [],\n            completionPrefix: lastDot,\n            line: q.line - i,\n            offset: q.offset,\n            file: filename,\n          }\n          return queryResult\n        }\n      }\n    })\n    partialQueries = partialQueries.concat(lspedQueries)\n\n    // Sets the file in the compiler as being without the comments\n    const newEditedFileCode = codeLines.join(\"\\n\")\n    env.updateFile(filename, newEditedFileCode)\n  }\n\n  // We need to also strip the highlights + queries from the main file which is shown to people\n  const allCodeLines = code.split(/\\r\\n?|\\n/g)\n  filterHighlightLines(allCodeLines)\n  code = allCodeLines.join(\"\\n\")\n\n  // Lets fs changes propagate back up to the fsMap\n  if (handbookOptions.emit) {\n    filenames.forEach(f => {\n      const filetype = f.split(\".\").pop() || \"\"\n      if (!sourceFiles.includes(filetype)) return\n\n      const output = ls.getEmitOutput(f)\n      output.outputFiles.forEach(output => {\n        system.writeFile(output.name, output.text)\n      })\n    })\n  }\n\n  // Code should now be safe to compile, so we're going to split it into different files\n  let errs: import(\"typescript\").Diagnostic[] = []\n  // Let because of a filter when cutting\n  let staticQuickInfos: TwoSlashReturn[\"staticQuickInfos\"] = []\n\n  // Iterate through the declared files and grab errors and LSP quickinfos\n  // const declaredFiles = Object.keys(fileMap)\n\n  filenames.forEach(file => {\n    const filetype = file.split(\".\").pop() || \"\"\n\n    // Only run the LSP-y things on source files\n    if (!sourceFiles.includes(filetype)) {\n      return\n    }\n\n    if (!handbookOptions.noErrors) {\n      errs = errs.concat(ls.getSemanticDiagnostics(file), ls.getSyntacticDiagnostics(file))\n    }\n\n    const source = env.sys.readFile(file)!\n    const sourceFile = env.getSourceFile(file)\n    if (!sourceFile) {\n      throw new TwoslashError(\n        `Could not find a  TypeScript sourcefile for '${file}' in the Twoslash vfs`,\n        `It's a little hard to provide useful advice on this error. Maybe you imported something which the compiler doesn't think is a source file?`,\n        ``\n      )\n    }\n\n    // Get all of the interesting quick info popover\n    if (!handbookOptions.showEmit) {\n      const fileContentStartIndexInModifiedFile = code.indexOf(source) == -1 ? 0 : code.indexOf(source)\n      const linesAbove = code.slice(0, fileContentStartIndexInModifiedFile).split(\"\\n\").length - 1\n\n      // Get all interesting identifiers in the file, so we can show hover info for it\n      const identifiers = handbookOptions.noStaticSemanticInfo ? [] : getIdentifierTextSpans(ts, sourceFile)\n      for (const identifier of identifiers) {\n        const span = identifier.span\n        const quickInfo = ls.getQuickInfoAtPosition(file, span.start)\n\n        if (quickInfo && quickInfo.displayParts) {\n          const text = quickInfo.displayParts.map(dp => dp.text).join(\"\")\n          const targetString = identifier.text\n          const docs = quickInfo.documentation ? quickInfo.documentation.map(d => d.text).join(\"\\n\") : undefined\n\n          // Get the position of the\n          const position = span.start + fileContentStartIndexInModifiedFile\n          // Use TypeScript to pull out line/char from the original code at the position + any previous offset\n          const burnerSourceFile = ts.createSourceFile(\"_.ts\", code, ts.ScriptTarget.ES2015)\n          const { line, character } = ts.getLineAndCharacterOfPosition(burnerSourceFile, position)\n\n          staticQuickInfos.push({ text, docs, start: position, length: span.length, line, character, targetString })\n        }\n      }\n\n      // Offset the queries for this file because they are based on the line for that one\n      // specific file, and not the global twoslash document. This has to be done here because\n      // in the above loops, the code for queries/highlights/etc hasn't been stripped yet.\n      partialQueries\n        .filter((q: any) => q.file === file)\n        .forEach(q => {\n          const pos =\n            ts.getPositionOfLineAndCharacter(sourceFile, q.line, q.offset) + fileContentStartIndexInModifiedFile\n\n          switch (q.kind) {\n            case \"query\": {\n              queries.push({\n                docs: q.docs,\n                kind: \"query\",\n                start: pos + fileContentStartIndexInModifiedFile,\n                length: q.text.length,\n                text: q.text,\n                offset: q.offset,\n                line: q.line + linesAbove + 1,\n              })\n              break\n            }\n            case \"completions\": {\n              queries.push({\n                completions: q.completions,\n                kind: \"completions\",\n                start: pos + fileContentStartIndexInModifiedFile,\n                completionsPrefix: q.completionPrefix,\n                length: 1,\n                offset: q.offset,\n                line: q.line + linesAbove + 1,\n              })\n            }\n          }\n        })\n    }\n  })\n\n  const relevantErrors = errs.filter(e => e.file && filenames.includes(e.file.fileName))\n\n  // A validator that error codes are mentioned, so we can know if something has broken in the future\n  if (!handbookOptions.noErrorValidation && relevantErrors.length) {\n    validateCodeForErrors(relevantErrors, handbookOptions, extension, originalCode, fsRoot)\n  }\n\n  let errors: TwoSlashReturn[\"errors\"] = []\n\n  // We can't pass the ts.DiagnosticResult out directly (it can't be JSON.stringified)\n  for (const err of relevantErrors) {\n    const codeWhereErrorLives = env.sys.readFile(err.file!.fileName)!\n    const fileContentStartIndexInModifiedFile = code.indexOf(codeWhereErrorLives)\n    const renderedMessage = ts.flattenDiagnosticMessageText(err.messageText, \"\\n\")\n    const id = `err-${err.code}-${err.start}-${err.length}`\n    const { line, character } = ts.getLineAndCharacterOfPosition(err.file!, err.start!)\n\n    errors.push({\n      category: err.category,\n      code: err.code,\n      length: err.length,\n      start: err.start ? err.start + fileContentStartIndexInModifiedFile : undefined,\n      line,\n      character,\n      renderedMessage,\n      id,\n    })\n  }\n\n  // Handle emitting files\n  if (handbookOptions.showEmit) {\n    // Get the file which created the file we want to show:\n    const emitFilename = handbookOptions.showEmittedFile || defaultFileName\n    const emitSourceFilename =\n      fsRoot + emitFilename.replace(\".jsx\", \"\").replace(\".js\", \"\").replace(\".d.ts\", \"\").replace(\".map\", \"\")\n\n    let emitSource = filenames.find(f => f === emitSourceFilename + \".ts\" || f === emitSourceFilename + \".tsx\")\n\n    if (!emitSource && !compilerOptions.outFile) {\n      const allFiles = filenames.join(\", \")\n      // prettier-ignore\n      throw new TwoslashError(\n        `Could not find source file to show the emit for`,\n        `Cannot find the corresponding **source** file  ${emitFilename} for completions via ^| returned no quickinfo from the compiler.`,\n        `Looked for: ${emitSourceFilename} in the vfs - which contains: ${allFiles}`\n      )\n    }\n\n    // Allow outfile, in which case you need any file.\n    if (compilerOptions.outFile) {\n      emitSource = filenames[0]\n    }\n\n    const output = ls.getEmitOutput(emitSource!)\n    const file = output.outputFiles.find(\n      o => o.name === fsRoot + handbookOptions.showEmittedFile || o.name === handbookOptions.showEmittedFile\n    )\n\n    if (!file) {\n      const allFiles = output.outputFiles.map(o => o.name).join(\", \")\n      throw new TwoslashError(\n        `Cannot find the output file in the Twoslash VFS`,\n        `Looking for ${handbookOptions.showEmittedFile} in the Twoslash vfs after compiling`,\n        `Looked for\" ${fsRoot + handbookOptions.showEmittedFile} in the vfs - which contains ${allFiles}.`\n      )\n    }\n\n    code = file.text\n    extension = file.name.split(\".\").pop()!\n\n    // Remove highlights and queries, because it won't work across transpiles,\n    // though I guess source-mapping could handle the transition\n    highlights = []\n    partialQueries = []\n    staticQuickInfos = []\n  }\n\n  const zippedCode = lzstring.compressToEncodedURIComponent(originalCode)\n  const playgroundURL = `https://www.typescriptlang.org/play/#code/${zippedCode}`\n\n  // Cutting happens last, and it means editing the lines and character index of all\n  // the type annotations which are attached to a location\n\n  const cutString = \"// ---cut---\\n\"\n  if (code.includes(cutString)) {\n    // Get the place it is, then find the end and the start of the next line\n    const cutIndex = code.indexOf(cutString) + cutString.length\n    const lineOffset = code.substr(0, cutIndex).split(\"\\n\").length - 1\n\n    // Kills the code shown\n    code = code.split(cutString).pop()!\n\n    // For any type of metadata shipped, it will need to be shifted to\n    // fit in with the new positions after the cut\n    staticQuickInfos.forEach(info => {\n      info.start -= cutIndex\n      info.line -= lineOffset\n    })\n    staticQuickInfos = staticQuickInfos.filter(s => s.start > -1)\n\n    errors.forEach(err => {\n      if (err.start) err.start -= cutIndex\n      if (err.line) err.line -= lineOffset\n    })\n    errors = errors.filter(e => e.start && e.start > -1)\n\n    highlights.forEach(highlight => {\n      highlight.start -= cutIndex\n      highlight.line -= lineOffset\n    })\n\n    highlights = highlights.filter(e => e.start > -1)\n\n    queries.forEach(q => (q.line -= lineOffset))\n    queries = queries.filter(q => q.line > -1)\n\n    tags.forEach(q => (q.line -= lineOffset))\n    tags = tags.filter(q => q.line > -1)\n  }\n\n  const cutAfterString = \"// ---cut-after---\\n\"\n\n  if (code.includes(cutAfterString)) {\n    \n    // Get the place it is, then find the end and the start of the next line\n    const cutIndex = code.indexOf(cutAfterString) + cutAfterString.length\n    const lineOffset = code.substr(0, cutIndex).split(\"\\n\").length - 1\n\n    // Kills the code shown, removing any whitespace on the end\n    code = code.split(cutAfterString).shift()!.trimEnd()\n    \n    // Cut any metadata after the cutAfterString\n    staticQuickInfos = staticQuickInfos.filter(s => s.line < lineOffset)\n    errors = errors.filter(e => e.line && e.line < lineOffset)\n    highlights = highlights.filter(e => e.line < lineOffset)\n    queries = queries.filter(q => q.line < lineOffset)\n    tags = tags.filter(q => q.line < lineOffset)\n  }\n\n  return {\n    code,\n    extension,\n    highlights,\n    queries,\n    staticQuickInfos,\n    errors,\n    playgroundURL,\n    tags,\n  }\n}\n\nconst splitTwoslashCodeInfoFiles = (code: string, defaultFileName: string, root: string) => {\n  const lines = code.split(/\\r\\n?|\\n/g)\n\n  let nameForFile = code.includes(`@filename: ${defaultFileName}`) ? \"global.ts\" : defaultFileName\n  let currentFileContent: string[] = []\n  const fileMap: Array<[string, string[]]> = []\n\n  for (const line of lines) {\n    if (line.includes(\"// @filename: \")) {\n      fileMap.push([root + nameForFile, currentFileContent])\n      nameForFile = line.split(\"// @filename: \")[1].trim()\n      currentFileContent = []\n    } else {\n      currentFileContent.push(line)\n    }\n  }\n  fileMap.push([root + nameForFile, currentFileContent])\n\n  // Basically, strip these:\n  // [\"index.ts\", []]\n  // [\"index.ts\", [\"\"]]\n  const nameContent = fileMap.filter(n => n[1].length > 0 && (n[1].length > 1 || n[1][0] !== \"\"))\n  return nameContent\n}\n"],"names":["parsePrimitive","value","type","toLowerCase","length","TwoslashError","cleanMarkdownEscaped","code","replace","typesToExtension","types","map","js","javascript","ts","typescript","tsx","jsx","json","jsn","Object","keys","getIdentifierTextSpans","sourceFile","textSpans","checkChildren","node","forEachChild","child","isIdentifier","start","getStart","push","span","createTextSpan","end","text","getText","getClosestWord","str","pos","String","Number","left","slice","search","right","word","startPos","validateCodeForErrors","relevantErrors","handbookOptions","extension","originalCode","vfsRoot","inErrsButNotFoundInTheHeader","filter","e","errors","includes","errorsFound","Array","from","Set","join","errorsToShow","codeToAdd","missing","filesToErrors","noFiles","forEach","d","fileRef","file","fileName","existing","showDiagnostics","title","diags","msg","messageText","innerDiags","filepath","allMessages","newErr","validateInput","hasLocalStorage","localStorage","error","hasProcess","process","shouldDebug","getItem","env","DEBUG","log","console","_message","description","recommendation","message","Error","filterHighlightLines","codeLines","highlights","queries","nextContentOffset","contentOffset","removedLines","line","i","moveForward","stripLine","logDesc","splice","highlightMatch","exec","queryMatch","removePrettierIgnoreMatch","completionsQuery","indexOf","kind","offset","undefined","docs","lastIndexOf","trim","getOptionValueFromMap","name","key","optMap","result","get","setOption","opts","opt","elementType","element","strings","split","v","optionDeclarations","booleanConfigRegexp","valuedConfigRegexp","filterCompilerOptions","defaultCompilerOptions","options","match","filterCustomTags","customTags","tags","annotation","defaultHandbookOptions","noErrors","showEmit","showEmittedFile","noStaticSemanticInfo","emit","noErrorValidation","filterHandbookOptions","twoslasher","tsModule","require","lzstring","lzstringModule","safeExtension","defaultFileName","strict","target","ScriptTarget","ES2016","allowJs","defaultOptions","compilerOptions","JsxEmit","Preserve","getRoot","pa","path","rootPath","cwd","sep","posix","useFS","fsMap","vfs","Map","system","createSystem","createFSBackedSystem","fsRoot","createVirtualTypeScriptEnvironment","customTransformers","ls","languageService","partialQueries","nameContent","splitTwoslashCodeInfoFiles","sourceFiles","filenames","nc","filename","filetype","pop","allowJSON","resolveJsonModule","newFileCode","createFile","updates","concat","lspedQueries","q","getSourceFile","position","getPositionOfLineAndCharacter","quickInfo","getQuickInfoAtPosition","displayParts","dp","documentation","queryResult","completions","getCompletionsAtPosition","prefix","lastDot","entries","completionPrefix","newEditedFileCode","updateFile","allCodeLines","f","output","getEmitOutput","outputFiles","writeFile","errs","staticQuickInfos","getSemanticDiagnostics","getSyntacticDiagnostics","source","sys","readFile","fileContentStartIndexInModifiedFile","linesAbove","identifiers","identifier","targetString","burnerSourceFile","createSourceFile","ES2015","getLineAndCharacterOfPosition","character","completionsPrefix","err","codeWhereErrorLives","renderedMessage","flattenDiagnosticMessageText","id","category","emitFilename","emitSourceFilename","emitSource","find","outFile","allFiles","o","zippedCode","compressToEncodedURIComponent","playgroundURL","cutString","cutIndex","lineOffset","substr","info","s","highlight","cutAfterString","shift","trimEnd","root","lines","nameForFile","currentFileContent","fileMap","n"],"mappings":"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"}